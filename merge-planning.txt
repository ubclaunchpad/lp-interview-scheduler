Give two interviewers' availabilities, return all common time blocks
- merge each interviewer's availabilities to make continuous time intervals (e.g. 10-10:30 and 10:30-11 becomes 10-11)
- sort both arrays
- find overlapping time blocks

public static void main(String[] args) {
        List<int[]> a1 = new ArrayList<>();
        List<int[]> a2 = new ArrayList<>();

        a1.add(new int[]{1000,1200});
        a1.add(new int[]{1300,1400});

        a2.add(new int[]{1015,1045});
        a2.add(new int[]{1100,1130});

        List<int[]> output = findOverlapping(a1, a2);
        System.out.println("result: ");
        for (int[] timeblock : output) {
            System.out.println(timeblock[0] + "," + timeblock[1]);
        }
}

function findOverlapping(availabilities1, availabilities2) {
    // where availabilities1 and availabilities2 are the sorted, continuous time interval arrays representing the interviewers availabilities
    // e.g. availabilities1 = [[10, 11], [11:30, 12:30], [1:00, 4:00]] where each subarray is an object

    int idx1 = 0;
    int idx2 = 0;

    AvailabilityObject currAvailability;
    AvailabilityObject prevAvailability;
    List<AvailabilityObject> output;

    while (idx1 < availabilities1.size() && idx2 < availabilities2.size()) {
        if (availabilities1[idx1][0] < availabilities2[idx2][0]) {
            currAvailability = availabilities1[idx1];
            idx1++;
        } else {
            currAvailability = availabilities2[idx2];
            idx2++;
        }

        if (prevAvailability != null) {
            if (currAvailability[0] < prevAvailability[1]) {
                int startTime = currAvailability[0];
                int endTime = min(currAvailability[1], prevAvailability[1]);
                AvailabilityObject newAvailability = {startTime, endTime}
                output.add(newAvailability);


                if (currAvailability[1] < prevAvailability[1]) {
                    prevAvailability = {currAvailability[1], prevAvailability[1]}
                } else {
                    prevAvailability = currAvailability;
                }
            }
        } else {
            prevAvailability = currAvailability;
        }
        
    }
    return output;
}


///////////////////////////////////////////////////////////////
// Working java solution:

 public static List<int[]> findOverlapping(List<int[]> availabilities1, List<int[]> availabilities2) {
        // where availabilities1 and availabilities2 are the sorted, continuous time interval arrays representing the interviewers availabilities
        // e.g. availabilities1 = [[10, 11], [11:30, 12:30], [1:00, 4:00]] where each subarray is an object

        int idx1 = 0;
        int idx2 = 0;

        int[] currAvailability;
        int[] prevAvailability = null;
        List<int[]> output = new ArrayList<>();

        while (idx1 < availabilities1.size() && idx2 < availabilities2.size()) {
            if (availabilities1.get(idx1)[0] < availabilities2.get(idx2)[0]) {
                currAvailability = availabilities1.get(idx1);
                idx1++;
            } else {
                currAvailability = availabilities2.get(idx2);
                idx2++;
            }

            if (prevAvailability != null) {
                if (currAvailability[0] < prevAvailability[1]) {
                    int startTime = currAvailability[0];
                    int endTime = Math.min(currAvailability[1], prevAvailability[1]);
                    int[] newAvailability = {startTime, endTime};
                    output.add(newAvailability);


                    if (currAvailability[1] < prevAvailability[1]) {
                        prevAvailability = new int[]{currAvailability[1], prevAvailability[1]};
                    } else {
                        prevAvailability = currAvailability;
                    }
                }
            } else {
                prevAvailability = currAvailability;
            }

        }
        return output;
    }